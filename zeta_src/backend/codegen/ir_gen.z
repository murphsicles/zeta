// zeta_src/backend/codegen/ir_gen.z
use zeta::middle::mir::mir::{Mir, MirExpr, MirStmt, SemiringOp};

pub struct IRGen {
    ir: String,
    next_reg: u32,
    next_label: u32,
    string_counter: u32,
    locals: HashMap<u32, String>,
}

impl IRGen {
    pub fn new() -> Self {
        Self {
            ir: String::new(),
            next_reg: 0,
            next_label: 0,
            string_counter: 0,
            locals: HashMap::new(),
        }
    }

    pub fn gen_mirs(&mut self, mirs: &[Mir]) {
        self.gen_start();
        for mir in mirs {
            self.gen_fn(mir);
        }
    }

    fn gen_start(&mut self) {
        self.emit("define void @_start() {");
        self.emit("entry:");
        self.emit("%0 = call i64 @main()");
        self.emit("ret void");
        self.emit("}");
    }

    fn gen_fn(&mut self, mir: &Mir) {
        let fn_name = mir.name.as_ref().cloned().unwrap_or("anon".to_string());
        let param_types = (0..mir.param_indices.len()).map(|_| "i64".to_string()).collect::<Vec<_>>().join(", ");
        self.emit(&format!("define i64 @{}({}) {{", fn_name, param_types));
        self.emit("entry:");
        self.locals.clear();
        for (i, (_, arg_index)) in mir.param_indices.iter().enumerate() {
            let param = format!("%{}", i);
            let alloca = self.next_reg();
            self.emit(&format!("{} = alloca i64", alloca));
            self.emit(&format!("store i64 {}, i64* {}", param, alloca));
            self.locals.insert(*arg_index, alloca);
        }
        for stmt in &mir.stmts {
            self.gen_stmt(stmt, mir);
        }
        if !mir.stmts.iter().any(|s| matches!(s, MirStmt::Return { .. })) {
            self.emit("ret i64 0");
        }
        self.emit("}");
    }

    fn gen_stmt(&mut self, stmt: &MirStmt, mir: &Mir) {
        match stmt {
            MirStmt::Assign { lhs, rhs } => {
                let rhs_val = self.gen_expr(rhs, mir);
                let lhs_alloca = self.locals.get(lhs).cloned().unwrap();
                self.emit(&format!("store i64 {}, i64* {}", rhs_val, lhs_alloca));
            }
            MirStmt::Call { func, args, dest, type_args: _ } => {
                let arg_vals = args.iter().map(|&id| self.gen_expr(&mir.exprs[id], mir)).collect::<Vec<_>>().join(", i64 ");
                let call = self.next_reg();
                self.emit(&format!("{} = call i64 @{}({})", call, func, arg_vals));
                let alloca = self.next_reg();
                self.emit(&format!("{} = alloca i64", alloca));
                self.emit(&format!("store i64 {}, i64* {}", call, alloca));
                self.locals.insert(*dest, alloca);
            }
            MirStmt::VoidCall { func, args } => {
                let arg_vals = args.iter().map(|&id| self.gen_expr(&mir.exprs[id], mir)).collect::<Vec<_>>().join(", i64 ");
                self.emit(&format!("call void @{}({})", func, arg_vals));
            }
            MirStmt::Return { val } => {
                let val = self.gen_expr(&mir.exprs[val], mir);
                self.emit(&format!("ret i64 {}", val));
            }
            MirStmt::SemiringFold { op, values, result } => {
                let mut acc = self.gen_expr(&mir.exprs[values[0]], mir);
                for &val_id in &values[1..] {
                    let val = self.gen_expr(&mir.exprs[val_id], mir);
                    let tmp = self.next_reg();
                    let instr = if *op == SemiringOp::Add { "add" } else { "mul" };
                    self.emit(&format!("{} = {} i64 {}, {}", tmp, instr, acc, val));
                    acc = tmp;
                }
                let alloca = self.next_reg();
                self.emit(&format!("{} = alloca i64", alloca));
                self.emit(&format!("store i64 {}, i64* {}", acc, alloca));
                self.locals.insert(*result, alloca);
            }
            MirStmt::If { cond, then, else_ } => {
                let cond_val = self.gen_expr(&mir.exprs[cond], mir);
                let then_bb = self.next_label();
                let else_bb = self.next_label();
                let cont_bb = self.next_label();
                self.emit(&format!("br i1 {}, label %{}, label %{}", cond_val, then_bb, else_bb));
                self.emit(&format!("%{}:", then_bb));
                for s in then {
                    self.gen_stmt(s, mir);
                }
                self.emit(&format!("br label %{}", cont_bb));
                self.emit(&format!("%{}:", else_bb));
                for s in else_ {
                    self.gen_stmt(s, mir);
                }
                self.emit(&format!("br label %{}", cont_bb));
                self.emit(&format!("%{}:", cont_bb));
            }
            MirStmt::TryProp { expr_id, ok_dest, err_dest } => {
                let expr_val = self.gen_expr(&mir.exprs[expr_id], mir);
                let is_ok = self.next_reg();
                self.emit(&format!("{} = call i64 @result_is_ok(i64 {})", is_ok, expr_val));
                let ok_bb = self.next_label();
                let err_bb = self.next_label();
                let cont_bb = self.next_label();
                self.emit(&format!("br i1 {}, label %{}, label %{}", is_ok, ok_bb, err_bb));
                self.emit(&format!("%{}:", ok_bb));
                let data = self.next_reg();
                self.emit(&format!("{} = call i64 @result_get_data(i64 {})", data, expr_val));
                let ok_alloca = self.next_reg();
                self.emit(&format!("{} = alloca i64", ok_alloca));
                self.emit(&format!("store i64 {}, i64* {}", data, ok_alloca));
                self.locals.insert(*ok_dest, ok_alloca);
                self.emit(&format!("br label %{}", cont_bb));
                self.emit(&format!("%{}:", err_bb));
                let err_alloca = self.next_reg();
                self.emit(&format!("{} = alloca i64", err_alloca));
                self.emit(&format!("store i64 {}, i64* {}", expr_val, err_alloca));
                self.locals.insert(*err_dest, err_alloca);
                self.emit(&format!("br label %{}", cont_bb));
                self.emit(&format!("%{}:", cont_bb));
            }
            MirStmt::MapNew { dest } => {
                let call = self.next_reg();
                self.emit(&format!("{} = call i64 @host_map_new()", call));
                let alloca = self.next_reg();
                self.emit(&format!("{} = alloca i64", alloca));
                self.emit(&format!("store i64 {}, i64* {}", call, alloca));
                self.locals.insert(*dest, alloca);
            }
            MirStmt::DictInsert { map_id, key_id, val_id } => {
                let map = self.gen_expr(&mir.exprs[map_id], mir);
                let key = self.gen_expr(&mir.exprs[key_id], mir);
                let val = self.gen_expr(&mir.exprs[val_id], mir);
                self.emit(&format!("call void @host_map_insert(i64 {}, i64 {}, i64 {}", map, key, val));
            }
            MirStmt::DictGet { map_id, key_id, dest } => {
                let map = self.gen_expr(&mir.exprs[map_id], mir);
                let key = self.gen_expr(&mir.exprs[key_id], mir);
                let call = self.next_reg();
                self.emit(&format!("{} = call i64 @host_map_get(i64 {}, i64 {})", call, map, key));
                let alloca = self.next_reg();
                self.emit(&format!("{} = alloca i64", alloca));
                self.emit(&format!("store i64 {}, i64* {}", call, alloca));
                self.locals.insert(*dest, alloca);
            }
        }
    }

    fn gen_expr(&mut self, expr: &MirExpr, mir: &Mir) -> String {
        match expr {
            MirExpr::Var(id) => self.gen_expr(&mir.exprs[id], mir),
            MirExpr::Lit(n) => format!("{}", n),
            MirExpr::StringLit(s) => {
                let global = format!("@str{}", self.string_counter);
                self.string_counter += 1;
                let bytes = s.as_bytes().iter().map(|b| b.to_string()).collect::<Vec<_>>().join(", ");
                let len = s.len() + 1;
                self.emit(&format!("{} = private constant [{} x i8] [{} , i8 0]", global, len, bytes));
                let ptr = self.next_reg();
                self.emit(&format!("{} = getelementptr [{} x i8], [{} x i8]* {}, i32 0, i32 0", ptr, len, len, global));
                let i64_ptr = self.next_reg();
                self.emit(&format!("{} = ptrtoint i8* {} to i64", i64_ptr, ptr));
                i64_ptr
            }
            MirExpr::FString(ids) => {
                if ids.is_empty() {
                    return "0".to_string();
                }
                let mut res = self.gen_expr(&mir.exprs[ids[0]], mir);
                for &id in &ids[1..] {
                    let next = self.gen_expr(&mir.exprs[id], mir);
                    let call = self.next_reg();
                    self.emit(&format!("{} = call i64 @host_str_concat(i64 {}, i64 {})", call, res, next));
                    res = call;
                }
                res
            }
            MirExpr::ConstEval(n) => format!("{}", n),
            MirExpr::TimingOwned(inner_id) => self.gen_expr(&mir.exprs[inner_id], mir),
        }
    }

    fn next_reg(&mut self) -> String {
        let r = self.next_reg;
        self.next_reg += 1;
        format!("%{}", r)
    }

    fn next_label(&mut self) -> String {
        let l = self.next_label;
        self.next_label += 1;
        format!("L{}", l)
    }

    fn emit(&mut self, line: &str) {
        self.ir.push_str(&format!("  {}\n", line)); // Assume 2-space indent
    }
}
