// zeta_src/tests.z
//! Unit tests for Zeta compiler.
//! Verifies parsing, type checking, code generation, resolution, and runtime features.
//! Ported from src/tests.rs; uses simple Zeta-based testing framework (assert_eq macro stubbed as panic on fail).

use zeta::frontend::ast::AstNode;
use zeta::frontend::parser::top_level::parse_zeta; // Now using ported Zeta parser
use zeta::middle::mir::mir::Mir;
use zeta::middle::resolver::resolver::{Resolver, MonoKey};
use zeta::compile_and_run_zeta; // From main.z utilities

macro assert_eq(a: any, b: any) {
    if a != b {
        panic("Assertion failed: {} != {}", a, b);
    }
}

macro assert(cond: bool) {
    if !cond {
        panic("Assertion failed");
    }
}

fn test_parse_addable() {
    let input = r#"
concept Addable<Rhs=Self> {
    fn add(self: Self, rhs: Rhs) -> Self;
}
"#;
    let (_, asts) = parse_zeta(input).unwrap();
    assert_eq(asts.len(), 1);
    if let AstNode::ConceptDef { name, params, .. } = &asts[0] {
        assert_eq(name, "Addable");
        assert_eq(params, vec!["Rhs"]);
    }
}

fn test_typecheck_impl() {
    let input = r#"
concept Send {}
impl Send for i32 {}
"#;
    let (_, asts) = parse_zeta(input).unwrap();
    let mut res = Resolver::new();
    for ast in &asts {
        res.register(ast.clone());
    }
    assert(res.typecheck(&asts));
}

fn test_codegen_run() {
    let input = r#"
fn simple() -> i32 { 42 }
"#;
    let res = compile_and_run_zeta(input).unwrap();
    assert_eq(res, 0);
}

fn test_ergonomics_infer() {
    let input = r#"
fn test_phantom<T>() -> T { TimingOwned<i32> 0 }
"#;
    let (_, asts) = parse_zeta(input).unwrap();
    let mut res = Resolver::new();
    for ast in &asts {
        res.register(ast.clone());
    }
    assert(res.typecheck(&asts));
}

fn test_derive_copy() {
    let input = r#"#[derive(Copy)] struct Foo(i32);"#;
    let (_, asts) = parse_zeta(input).unwrap();
    let mut res = Resolver::new();
    for ast in &asts {
        res.register(ast.clone());
    }
    assert(res.resolve_impl("Copy", "Foo").is_some());
}

fn test_mir_gen() {
    let input = r#"
fn test() -> i32 {
    let x = 42;
    x
}
"#;
    let (_, asts) = parse_zeta(input).unwrap();
    let mut res = Resolver::new();
    for ast in &asts {
        res.register(ast.clone());
    }
    let ast_hash = format!("{:?}", asts[0]);
    let mir = res.get_cached_mir(&ast_hash).unwrap();
    assert(!mir.stmts.is_empty());
}

fn test_parallel_resolve() {
    let input = r#"
concept A {}
concept B {}
impl A for i32 {}
impl B for i32 {}
"#;
    let (_, asts) = parse_zeta(input).unwrap();
    let mut res = Resolver::new();
    for ast in &asts {
        res.register(ast.clone());
    }
    assert(res.typecheck(&asts));
}

fn test_ctfe_semiring() {
    let input = r#"
fn semiring_test() -> i32 {
    let a = 2;
    let b = 3;
    let c = a.add(b);
    c
}
"#;
    let (_, asts) = parse_zeta(input).unwrap();
    let mut res = Resolver::new();
    for ast in &asts {
        res.register(ast.clone());
    }
    let ast_hash = format!("{:?}", asts[0]);
    let mir = res.get_cached_mir(&ast_hash).unwrap();
    assert(mir.ctfe_consts.contains_key(&2));
    assert_eq(*mir.ctfe_consts.get(&2).unwrap(), 5);
}

fn test_thin_templates() {
    let input = r#"
fn generic_add<T>(a: T, b: T) -> T { a.add(b) }
"#;
    let (_, asts) = parse_zeta(input).unwrap();
    let mut res = Resolver::new();
    for ast in &asts {
        res.register(ast.clone());
    }
    let key = MonoKey(("generic_add".to_string(), vec!["i32".to_string()]));
    let mono_ast = res.monomorphize(key.clone(), &asts[0]);
    assert_eq(mono_ast.generics, vec![]);
    let mir = res.get_mono_mir(&key).unwrap();
    assert(!mir.stmts.is_empty());
}

fn test_cachesafe() {
    let input = r#"
concept CacheSafe {}
impl CacheSafe for i32 {}
actor SafeChannel ...(truncated 3792 characters)...check(&asts));
    assert(res.resolve_impl("Copy", "Pair").is_some());
    assert(res.resolve_impl("Eq", "Pair").is_some()); // Auto-derived
}

fn test_algebraic_fusion() {
    let input = r#"
fn fusion_test() -> i32 {
    let a = 1;
    let b = 2;
    let c = 3;
    ((a.add(b)).add(c)) // Should fuse to a.add(b.add(c))
}
"#;
    let (_, asts) = parse_zeta(input).unwrap();
    let mut res = Resolver::new();
    for ast in &asts {
        res.register(ast.clone());
    }
    assert(res.typecheck(&asts));
    let ast_hash = format!("{:?}", asts[0]);
    let mir = res.get_cached_mir(&ast_hash).unwrap();
    // Stub: Check for Fusion stmt
    assert(mir.stmts.iter().any(|s| matches!(s, MirStmt::Fusion { .. })));
}

fn test_eop_semiring_matrix() {
    let input = r#"
concept Semiring {
    fn add(self: Self, rhs: Self) -> Self;
    fn mul(self: Self, rhs: Self) -> Self;
    fn zero() -> Self;
    fn one() -> Self;
}
impl Semiring for i32 {
    fn add(self: i32, rhs: i32) -> i32 { self + rhs }
    fn mul(self: i32, rhs: i32) -> i32 { self * rhs }
    fn zero() -> i32 { 0 }
    fn one() -> i32 { 1 }
}
fn matrix_mul<A: Semiring>(a: [[A; 2]; 2], b: [[A; 2]; 2]) -> [[A; 2]; 2] {
    let mut res = [[A::zero(); 2]; 2];
    for i in 0..2 {
        for j in 0..2 {
            for k in 0..2 {
                res[i][j] = res[i][j].add(a[i][k].mul(b[k][j]));
            }
        }
    }
    res
}
fn eop_test() -> i32 {
    let a = [[1i32, 2]; [3, 4]];
    let b = [[5, 6]; [7, 8]];
    let c = matrix_mul(a, b);
    c[0][0] // 19
}
"#;
    let (_, asts) = parse_zeta(input).unwrap();
    let mut res = Resolver::new();
    for ast in &asts {
        res.register(ast.clone());
    }
    assert(res.typecheck(&asts));
    let res_val = compile_and_run_zeta(input).unwrap();
    assert_eq(res_val, 19); // EOP semiring test
}

fn test_actor_counter() {
    let input = r#"
concept Send {}
concept Sync {}
concept CacheSafe {}
impl Send for i32 {}
impl Sync for i32 {}
impl CacheSafe for i32 {}
actor Counter {
    async fn increment(&self, delta: i32) -> i32 { self.state + delta }
    state: i32 = 0;
}
fn actor_test() -> i32 {
    let c = spawn_actor Counter();
    c.increment(42);
    42
}
"#;
    let (_, asts) = parse_zeta(input).unwrap();
    let mut res = Resolver::new();
    for ast in &asts {
        res.register(ast.clone());
    }
    assert(res.typecheck(&asts));
    let res_val = compile_and_run_zeta(input).unwrap();
    assert_eq(res_val, 42); // Actor spawn/inc
}

fn test_stable_abi() {
    let input = r#"
#[stable_abi]
fn ffi_add(a: i32, b: i32) -> i32 { a + b } // No generics
"#;
    let (_, asts) = parse_zeta(input).unwrap();
    let mut res = Resolver::new();
    for ast in &asts {
        res.register(ast.clone());
    }
    assert(res.typecheck(&asts)); // Stable ABI check
}

fn test_assoc_fold_fusion() {
    let input = r#"
fn assoc_fold() -> i32 {
    let xs = [1, 2, 3, 4];
    xs.fold(0, |acc, x| acc.add(x)) // Fused semigroup
}
"#;
    let (_, asts) = parse_zeta(input).unwrap();
    let mut res = Resolver::new();
    for ast in &asts {
        res.register(ast.clone());
    }
    assert(res.typecheck(&asts));
    let res_val = compile_and_run_zeta(input).unwrap();
    assert_eq(res_val, 10); // 0+1+2+3+4
}

// Benchmark stubs (run manually or via main)
fn bench_semiring_add() {
    let input = r#"
fn bench_add() -> i32 {
    let mut sum = 0;
    for i in 0..1000 {
        sum = sum.add(i);
    }
    sum
}
"#;
    let start = host_datetime_now();
    let _ = compile_and_run_zeta(input).unwrap();
    let duration = host_datetime_now() - start;
    print("Semiring add bench: {}ms", duration);
    // Compare to Rust/Zig/Go (manual)
}

// Run all tests
fn run_all_tests() {
    test_parse_addable();
    test_typecheck_impl();
    test_codegen_run();
    test_ergonomics_infer();
    test_derive_copy();
    test_mir_gen();
    test_parallel_resolve();
    test_ctfe_semiring();
    test_thin_templates();
    test_cachesafe();
    test_algebraic_fusion();
    test_eop_semiring_matrix();
    test_actor_counter();
    test_stable_abi();
    test_assoc_fold_fusion();
    print("All tests passed!");
}

// Self-parsing validation test
fn test_self_parsing() {
    let self_code = read_file("zeta_src/main.z"); // Assume std::fs read
    let (_, asts) = parse_zeta(&self_code).unwrap();
    assert(asts.len() > 0);
    print("Self-parsing OK: Parsed {} nodes", asts.len());
}

fn main() -> i64 {
    run_all_tests();
    test_self_parsing();
    bench_semiring_add(); // Ensure no regressions
    0
}
