// zeta_src/middle/specialization.z
#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct MonoKey {
    pub func_name: String,
    pub type_args: Vec<String>,
}

#[derive(Clone, Debug)]
pub struct MonoValue {
    pub llvm_func_name: String,
    pub cache_safe: bool,
}

static mut CACHE: Vec<(MonoKey, MonoValue)> = vec![];

impl MonoKey {
    pub fn mangle(&self) -> String {
        if self.type_args.is_empty() {
            self.func_name.clone()
        } else {
            format!("{}_{}", self.func_name, self.type_args.join("_"))
        }
    }
}

pub fn lookup_specialization(key: &MonoKey) -> Option<MonoValue> {
    unsafe {
        CACHE.iter()
            .find(|(k, _)| k == key)
            .map(|(_, v)| v.clone())
    }
}

pub fn record_specialization(key: MonoKey, value: MonoValue) {
    unsafe {
        CACHE.push((key, value));
    }
}

pub fn is_cache_safe(ty: &str) -> bool {
    matches!(
        ty,
        "i64"
            | "i32"
            | "f64"
            | "f32"
            | "bool"
            | "u8"
            | "&i64"
            | "&str"
            | "Result_i64"
            | "Result_str"
            | "Map_i64_i64"
            | "Map_str_str"
            | "Map_i64_str"
    )
}
