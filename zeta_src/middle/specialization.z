// zeta_src/middle/specialization.z
// Complete specialization cache for Phase 2 (v0.2.2)
// Global static Vec â€” thread-unsafe for early bootstrap

#[derive(Clone, Debug, PartialEq, Eq, Hash)]
pub struct MonoKey {
    pub func_name: String,
    pub type_args: Vec<String>,
}

#[derive(Clone, Debug)]
pub struct MonoValue {
    pub llvm_func_name: String,
    pub cache_safe: bool,
}

impl MonoKey {
    pub fn mangle(&self) -> String {
        if self.type_args.is_empty() {
            self.func_name.clone()
        } else {
            format!("{}_{}", self.func_name, self.type_args.join("_"))
        }
    }
}

static mut CACHE: Vec<(MonoKey, MonoValue)> = vec![];

pub fn lookup_specialization(key: &MonoKey) -> Option<MonoValue> {
    unsafe {
        CACHE.iter()
            .find(|(k, _)| k == key)
            .map(|(_, v)| v.clone())
    }
}

pub fn record_specialization(key: MonoKey, value: MonoValue) {
    unsafe {
        if let Some(pos) = CACHE.iter().position(|(k, _)| k == &key) {
            CACHE[pos] = (key, value);
        } else {
            CACHE.push((key, value));
        }
    }
}

pub fn is_cache_safe(ty: &String) -> bool {
    matches!(
        ty.as_str(),
        "i64" | "i32" | "f64" | "f32" | "bool" | "u8" |
        "&i64" | "&str" |
        "Result_i64" | "Result_str" |
        "Map_i64_i64" | "Map_str_str" | "Map_i64_str"
    )
}
