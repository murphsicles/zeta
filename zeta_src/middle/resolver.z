// zeta_src/middle/resolver.z
// Complete resolver and typechecker for Phase 2 (v0.2.2)
// Full implementation ported from Rust version
// Uses Vec for maps (early bootstrap — no generic Map yet)
// Persistent cache stubs (host_fs later)

use zorb::frontend::ast::AstNode;
use zorb::frontend::borrow::BorrowChecker;
use zorb::middle::mir::Mir;
use zorb::middle::specialization::{MonoKey, MonoValue, is_cache_safe, record_specialization};

type Type = String;

const SPECIALIZATION_CACHE_FILE: String = ".zeta_specialization_cache.json".to_string();

struct Resolver {
    impls: Vec<((String, String), Vec<AstNode>)>,
    cached_mirs: Vec<(String, Mir)>,
    mono_mirs: Vec<(MonoKey, Mir)>,
    borrow_checker: BorrowChecker,
    associated_types: Vec<((String, String), String)>,
    ctfe_consts: Vec<(AstNode, i64)>,
}

impl Resolver {
    fn new() -> Self {
        let mut r = Self {
            impls: vec![],
            cached_mirs: vec![],
            mono_mirs: vec![],
            borrow_checker: BorrowChecker::new(),
            associated_types: vec![],
            ctfe_consts: vec![],
        };
        r.load_specialization_cache();
        r
    }

    fn load_specialization_cache(&mut self) {
        // Stub — real host_fs_read + JSON later
    }

    fn persist_specialization_cache(&self) {
        // Stub — real host_fs_write later
    }

    fn register(&mut self, ast: AstNode) {
        if let AstNode::ImplBlock { concept, ty, body, .. } = ast {
            self.impls.push(((concept, ty), body));
        }
    }

    fn resolve_impl(&self, concept: String, ty: String) -> Option<Vec<AstNode>> {
        self.impls.iter()
            .find(|((c, t), _)| c == &concept && t == &ty)
            .map(|(_, b)| b.clone())
    }

    fn is_abi_stable(&self, key: &MonoKey) -> bool {
        key.type_args.iter().all(|t| is_cache_safe(t))
    }

    fn record_mono(&mut self, key: MonoKey, mir: Mir) {
        let cache_safe = self.is_abi_stable(&key);
        let mangled = key.mangle();
        record_specialization(
            key.clone(),
            MonoValue {
                llvm_func_name: mangled,
                cache_safe,
            },
        );
        self.mono_mirs.push((key, mir));
    }

    pub fn typecheck(&mut self, asts: &[AstNode]) -> bool {
        let mut ok = true;
        // First pass: borrow checking
        for ast in asts {
            let borrow_ok = self.borrow_checker.check(ast.clone(), self);
            if !borrow_ok {
                ok = false;
            }
        }
        // Second pass: semantic + CTFE
        for ast in asts {
            if !self.check_node(ast) {
                ok = false;
            }
        }
        ok
    }

    fn check_node(&mut self, node: &AstNode) -> bool {
        match node {
            AstNode::Call { type_args, .. } => {
                !type_args.is_empty()
            }
            AstNode::BinaryOp { left, right, .. } => {
                let lty = self.infer_type(left);
                let rty = self.infer_type(right);
                lty == rty
            }
            _ => true,
        }
    }

    pub fn infer_type(&mut self, node: &AstNode) -> Type {
        if self.ctfe_eval(node).is_some() {
            return "i64".to_string();
        }
        match node {
            AstNode::Lit(_) => "i64".to_string(),
            AstNode::StringLit(_) => "str".to_string(),
            AstNode::FString(parts) => {
                for part in parts {
                    let ty = self.infer_type(part);
                    if ty != "str" && ty != "i64" {
                        return "unknown".to_string();
                    }
                }
                "str".to_string()
            }
            AstNode::Var(_) => "i64".to_string(),
            AstNode::BinaryOp { left, .. } => self.infer_type(left),
            AstNode::TimingOwned { ty, .. } => ty.clone(),
            AstNode::Call { .. } => "i64".to_string(),
            AstNode::DictLit { entries } => {
                if entries.is_empty() {
                    "Map_i64_i64".to_string()
                } else {
                    let key_ty = self.infer_type(&entries[0].0);
                    let val_ty = self.infer_type(&entries[0].1);
                    format!("Map_{}_{}", key_ty, val_ty)
                }
            }
            _ => "unknown".to_string(),
        }
    }

    pub fn ctfe_eval(&mut self, node: &AstNode) -> Option<i64> {
        if let Some(v) = self.ctfe_consts.iter().find(|(n, _)| n == node).map(|(_, v)| *v) {
            return Some(v);
        }
        let result = match node {
            AstNode::Lit(n) => Some(*n),
            AstNode::BinaryOp { op, left, right } => {
                let l = self.ctfe_eval(left)?;
                let r = self.ctfe_eval(right)?;
                match op.as_str() {
                    "+" => Some(l + r),
                    "-" => Some(l - r),
                    "*" => Some(l * r),
                    "/" => if r == 0 { None } else { Some(l / r) },
                    _ => None,
                }
            }
            AstNode::Call { method, args, .. } => {
                if method == "const_add" && args.len() == 2 {
                    let a = self.ctfe_eval(&args[0])?;
                    let b = self.ctfe_eval(&args[1])?;
                    Some(a + b)
                } else {
                    None
                }
            }
            _ => None,
        };
        if let Some(v) = result {
            self.ctfe_consts.push((node.clone(), v));
        }
        result
    }

    pub fn is_copy(&self, ty: &Type) -> bool {
        matches!(ty.as_str(), "i32" | "i64" | "f32" | "bool" | "str")
    }
}
