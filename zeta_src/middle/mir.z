// zeta_src/middle/mir.z
// Complete MIR definitions and lowering for Phase 2 (v0.2.2)
// Full port from Rust version with all variants and lowering logic

use zorb::frontend::ast::AstNode;

#[derive(Clone, Debug, PartialEq)]
pub struct Mir {
    pub name: Option<String>,
    pub param_indices: Vec<(String, u32)>,
    pub stmts: Vec<MirStmt>,
    pub exprs: Vec<(u32, MirExpr)>,
    pub ctfe_consts: Vec<(u32, i64)>,
    pub type_map: Vec<(u32, String)>,
}

#[derive(Clone, Debug, PartialEq)]
pub enum MirStmt {
    Assign { lhs: u32, rhs: u32 },
    Call {
        func: String,
        args: Vec<u32>,
        dest: u32,
        type_args: Vec<String>,
    },
    VoidCall { func: String, args: Vec<u32> },
    Return { val: u32 },
    SemiringFold { op: SemiringOp, values: Vec<u32>, result: u32 },
    If { cond: u32, then_: Vec<MirStmt>, else_: Vec<MirStmt> },
    TryProp { expr_id: u32, ok_dest: u32, err_dest: u32 },
    MapNew { dest: u32 },
    DictInsert { map_id: u32, key_id: u32, val_id: u32 },
    DictGet { map_id: u32, key_id: u32, dest: u32 },
}

#[derive(Clone, Debug, PartialEq)]
pub enum MirExpr {
    Var(u32),
    Lit(i64),
    StringLit(String),
    FString(Vec<u32>),
    ConstEval(i64),
    TimingOwned(u32),
}

#[derive(Clone, Copy, Debug, PartialEq)]
pub enum SemiringOp {
    Add,
    Mul,
}

pub struct MirGen {
    next_id: u32,
    stmts: Vec<MirStmt>,
    exprs: Vec<(u32, MirExpr)>,
    ctfe_consts: Vec<(u32, i64)>,
    defer_stmts: Vec<MirStmt>,
    type_map: Vec<(u32, String)>,
}

impl MirGen {
    pub fn new() -> Self {
        Self {
            next_id: 0,
            stmts: vec![],
            exprs: vec![],
            ctfe_consts: vec![],
            defer_stmts: vec![],
            type_map: vec![],
        }
    }

    pub fn lower_to_mir(&mut self, ast: &AstNode) -> Mir {
        self.lower_ast(ast);

        Mir {
            name: if let AstNode::FuncDef { name, .. } = ast {
                Some(name.clone())
            } else {
                None
            },
            param_indices: if let AstNode::FuncDef { params, .. } = ast {
                params.iter().enumerate().map(|(i, (n, _))| (n.clone(), i as u32)).collect()
            } else {
                vec![]
            },
            stmts: std::mem::take(&mut self.stmts),
            exprs: std::mem::take(&mut self.exprs),
            ctfe_consts: std::mem::take(&mut self.ctfe_consts),
            type_map: std::mem::take(&mut self.type_map),
        }
    }

    fn lower_ast(&mut self, ast: &AstNode) {
        match ast {
            AstNode::Assign(lhs, rhs) => {
                let rhs_id = self.lower_expr(rhs);
                let lhs_id = self.lower_expr(lhs);
                self.stmts.push(MirStmt::Assign { lhs: lhs_id, rhs: rhs_id });
            }
            AstNode::Return(inner) => {
                let val = self.lower_expr(inner);
                self.stmts.push(MirStmt::Return { val });
            }
            AstNode::BinaryOp { op, left, right } => {
                let left_id = self.lower_expr(left);
                let right_id = self.lower_expr(right);
                let dest = self.next_id();
                // Type lookup stub â€” use "i64" default
                let lty = "i64".to_string();
                let rty = "i64".to_string();
                if op == "+" && lty == "str" && rty == "str" {
                    self.stmts.push(MirStmt::Call {
                        func: "host_str_concat".to_string(),
                        args: vec![left_id, right_id],
                        dest,
                        type_args: vec![],
                    });
                } else if lty == "i64" && rty == "i64" {
                    let semiring_op = if op == "+" { SemiringOp::Add } else if op == "*" { SemiringOp::Mul } else { return; };
                    self.stmts.push(MirStmt::SemiringFold {
                        op: semiring_op,
                        values: vec![left_id, right_id],
                        result: dest,
                    });
                } else {
                    self.stmts.push(MirStmt::Call {
                        func: op.clone(),
                        args: vec![left_id, right_id],
                        dest,
                        type_args: vec![],
                    });
                }
                self.exprs.push((dest, MirExpr::Var(dest)));
            }
            AstNode::TryProp { expr } => {
                let expr_id = self.lower_expr(expr);
                let ok_dest = self.next_id();
                let err_dest = self.next_id();
                self.stmts.push(MirStmt::TryProp { expr_id, ok_dest, err_dest });
            }
            AstNode::DictLit { entries } => {
                let map_id = self.next_id();
                self.stmts.push(MirStmt::MapNew { dest: map_id });
                for (key, val) in entries {
                    let key_id = self.lower_expr(key);
                    let val_id = self.lower_expr(val);
                    self.stmts.push(MirStmt::DictInsert { map_id, key_id, val_id });
                }
                self.exprs.push((map_id, MirExpr::Var(map_id)));
            }
            AstNode::Subscript { base, index } => {
                let base_id = self.lower_expr(base);
                let index_id = self.lower_expr(index);
                let dest = self.next_id();
                self.stmts.push(MirStmt::DictGet { map_id: base_id, key_id: index_id, dest });
                self.exprs.push((dest, MirExpr::Var(dest)));
            }
            AstNode::Defer(inner) => {
                let mut subgen = MirGen::new();
                subgen.lower_ast(inner);
                self.defer_stmts.extend(subgen.stmts);
            }
            AstNode::If { cond, then_, else_ } => {
                let cond_id = self.lower_expr(cond);
                let mut then_stmts = vec![];
                for s in then_ {
                    let mut gen = MirGen::new();
                    gen.lower_ast(s);
                    then_stmts.extend(gen.stmts);
                }
                let mut else_stmts = vec![];
                for s in else_ {
                    let mut gen = MirGen::new();
                    gen.lower_ast(s);
                    else_stmts.extend(gen.stmts);
                }
                self.stmts.push(MirStmt::If { cond: cond_id, then_: then_stmts, else_: else_stmts });
            }
            AstNode::ExprStmt { expr } => {
                let _ = self.lower_expr(expr);
            }
            AstNode::FuncDef { body, .. } => {
                let mut collected_defers = vec![];
                for stmt in body {
                    if let AstNode::Defer(_) = stmt {
                        collected_defers.insert(0, stmt.clone());
                    }
                    self.lower_ast(stmt);
                }
                // Insert defers in reverse order before return/epilogue
                for defer_ast in collected_defers {
                    let mut subgen = MirGen::new();
                    subgen.lower_ast(&defer_ast);
                    self.stmts.extend(subgen.stmts);
                }
            }
            _ => {}
        }
    }

    fn lower_expr(&mut self, expr: &AstNode) -> u32 {
        let id = self.next_id();
        match expr {
            AstNode::Var(_) => {
                self.exprs.push((id, MirExpr::Var(id)));
                self.type_map.push((id, "i64".to_string()));
            }
            AstNode::Lit(n) => {
                self.exprs.push((id, MirExpr::Lit(*n)));
                self.type_map.push((id, "i64".to_string()));
            }
            AstNode::StringLit(s) => {
                self.exprs.push((id, MirExpr::StringLit(s.clone())));
                self.type_map.push((id, "str".to_string()));
            }
            AstNode::FString(parts) => {
                let part_ids: Vec<u32> = parts.iter().map(|p| self.lower_expr(p)).collect();
                self.exprs.push((id, MirExpr::FString(part_ids)));
                self.type_map.push((id, "str".to_string()));
            }
            AstNode::TimingOwned { inner, .. } => {
                let inner_id = self.lower_expr(inner);
                self.exprs.push((id, MirExpr::TimingOwned(inner_id)));
                self.type_map.push((id, "i64".to_string()));
            }
            _ => {
                self.exprs.push((id, MirExpr::Lit(0)));
                self.type_map.push((id, "i64".to_string()));
            }
        }
        id
    }

    fn next_id(&mut self) -> u32 {
        let id = self.next_id;
        self.next_id += 1;
        id
    }
}
