// zeta_src/main.z
// Full self-hosted Zeta compiler pipeline
// Parse → Resolve → MIR → Codegen → JIT (stub) → Execute main

use zorb::frontend::ast::AstNode;
use zorb::frontend::parser::{Lexer, Parser};
use zorb::middle::resolver::Resolver;
use zorb::middle::mir::{Mir, MirGen};
use zorb::backend::codegen::codegen::LLVMCodegen;
use zorb::backend::codegen::jit::finalize_and_jit;

fn compile(source: String) -> i64 {
    // Tokenize
    let mut lexer = Lexer::new(source);
    let tokens = lexer.tokenize();

    // Parse
    let mut parser = Parser::new(tokens);
    let ast = parser.parse();

    println!("=== Parsed AST ===");
    println!("{:#?}", ast);

    // Resolve / typecheck
    let mut resolver = Resolver::new();
    if let AstNode::Program(nodes) = ast {
        for node in &nodes {
            resolver.register(node.clone());
        }
        let type_ok = resolver.typecheck(nodes);
        if !type_ok {
            println!("Typecheck failed");
            return -1;
        }
    } else {
        println!("Not a program AST");
        return -1;
    }

    // Lower to MIR
    let mut mono_mirs = vec![];
    if let AstNode::Program(nodes) = ast {
        let mut mir_gen = MirGen::new();
        for node in nodes {
            if let AstNode::FuncDef { .. } = node {
                let mir = mir_gen.lower_to_mir(&node);
                mono_mirs.push(mir);
            }
        }
    }

    println!("=== Generated MIR ===");
    for mir in &mono_mirs {
        println!("{:#?}", mir);
    }

    // Codegen to LLVM IR
    let mut codegen = LLVMCodegen::new("zeta_module".to_string());
    codegen.gen_mirs(mono_mirs);

    let ir = codegen.finalize();
    println!("=== Generated LLVM IR ===");
    println!("{}", ir);

    // JIT and execute main
    match finalize_and_jit(codegen) {
        Ok(executor) => {
            if let Some(main_fn) = executor.get_main() {
                let result = main_fn();
                println!("Execution result: {}", result);
                result
            } else {
                println!("No main function found");
                -1
            }
        }
        Err(e) => {
            println!("JIT error: {}", e);
            -1
        }
    }
}

fn main() -> i64 {
    let test_source = r#"
fn main() -> i64 {
    let x = 40;
    let y = 2;
    return x + y;
}
"#;

    compile(test_source.to_string())
}
