// zeta_src/frontend/ast.z
// Full AST definition synchronized with Rust bootstrap compiler
// Complete for Phase 1 (v0.2.2) â€” all variants, fields, and doc/attrs support
#[derive(Clone, Debug, PartialEq)]
pub enum AstNode {
    Program(Vec<AstNode>),
    ConceptDef {
        name: String,
        generics: Vec<String>,
        methods: Vec<AstNode>,
        doc: String,
    },
    ImplBlock {
        concept: String,
        ty: String,
        body: Vec<AstNode>,
        doc: String,
    },
    FuncDef {
        name: String,
        generics: Vec<String>,
        params: Vec<(String, String)>,
        ret: String,
        body: Vec<AstNode>,
        attrs: Vec<String>,
        ret_expr: Option<Box<AstNode>>,
        single_line: bool,
        doc: String,
    },
    EnumDef {
        name: String,
        variants: Vec<(String, Vec<String>)>,
        doc: String,
    },
    StructDef {
        name: String,
        fields: Vec<(String, String)>,
        doc: String,
    },
    Call {
        receiver: Option<Box<AstNode>>,
        method: String,
        args: Vec<AstNode>,
        type_args: Vec<String>,
        structural: bool,
    },
    PathCall {
        path: Vec<String>,
        method: String,
        args: Vec<AstNode>,
    },
    Spawn {
        func: String,
        args: Vec<AstNode>,
    },
    Lit(i64),
    StringLit(String),
    FString(Vec<AstNode>),
    Var(String),
    Assign(Box<AstNode>, Box<AstNode>),
    BinaryOp {
        op: String,
        left: Box<AstNode>,
        right: Box<AstNode>,
    },
    TimingOwned {
        ty: String,
        inner: Box<AstNode>,
    },
    Defer(Box<AstNode>),
    TryProp {
        expr: Box<AstNode>,
    },
    DictLit {
        entries: Vec<(AstNode, AstNode)>,
    },
    Subscript {
        base: Box<AstNode>,
        index: Box<AstNode>,
    },
    Return(Box<AstNode>),
    If {
        cond: Box<AstNode>,
        then_: Vec<AstNode>,
        else_: Vec<AstNode>,
    },
    ExprStmt {
        expr: Box<AstNode>,
    },
}
