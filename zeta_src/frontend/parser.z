// zeta_src/frontend/parser.z
// Full recursive-descent parser for Zeta language
// Ported from Rust nom-based parser to pure Zeta implementation
// Supports top-level: fn, concept, impl, struct, enum
// Statements: assign, return, if/else, defer, expr-stmt
// Expressions: literals, var, call (method/static), binary ops (+ - * /), paren

#[derive(Clone, Debug, PartialEq)]
enum Token {
    Ident(String),
    KeywordFn,
    KeywordConcept,
    KeywordImpl,
    KeywordStruct,
    KeywordEnum,
    KeywordReturn,
    KeywordIf,
    KeywordElse,
    KeywordDefer,
    KeywordSpawn,
    Lit(i64),
    StringLit(String),
    LParen, RParen,
    LBrace, RBrace,
    LBracket, RBracket,
    Colon, Semi, Comma, Eq, Arrow,
    Plus, Minus, Star, Slash,
    Lt, Gt,
    Dot, Question,
    Eof,
}

struct Lexer {
    input: String,
    pos: i64,
    tokens: Vec<Token>,
}

impl Lexer {
    fn new(input: String) -> Self {
        Self { input, pos: 0, tokens: vec![] }
    }

    fn tokenize(&mut self) -> Vec<Token> {
        while self.pos < self.input.len() as i64 {
            let ch = self.peek();
            if ch.is_whitespace() {
                self.skip_whitespace();
                continue;
            }
            if ch.is_alphabetic() || ch == '_' {
                self.lex_ident_or_keyword();
            } else if ch.is_digit(10) {
                self.lex_number();
            } else if ch == '"' {
                self.lex_string();
            } else {
                self.lex_symbol();
            }
        }
        self.tokens.push(Token::Eof);
        self.tokens.clone()
    }

    fn peek(&self) -> char {
        self.input.chars().nth(self.pos as usize).unwrap_or('\0')
    }

    fn peek_next(&self) -> char {
        self.input.chars().nth((self.pos + 1) as usize).unwrap_or('\0')
    }

    fn advance(&mut self) {
        self.pos += 1;
    }

    fn skip_whitespace(&mut self) {
        while self.peek().is_whitespace() {
            self.advance();
        }
    }

    fn lex_ident_or_keyword(&mut self) {
        let mut word = String::new();
        while self.peek().is_alphanumeric() || self.peek() == '_' {
            word.push(self.peek());
            self.advance();
        }
        let tok = match word.as_str() {
            "fn" => Token::KeywordFn,
            "concept" => Token::KeywordConcept,
            "impl" => Token::KeywordImpl,
            "struct" => Token::KeywordStruct,
            "enum" => Token::KeywordEnum,
            "return" => Token::KeywordReturn,
            "if" => Token::KeywordIf,
            "else" => Token::KeywordElse,
            "defer" => Token::KeywordDefer,
            "spawn" => Token::KeywordSpawn,
            _ => Token::Ident(word),
        };
        self.tokens.push(tok);
    }

    fn lex_number(&mut self) {
        let mut num: i64 = 0;
        while self.peek().is_digit(10) {
            num = num * 10 + (self.peek() as i64 - '0' as i64);
            self.advance();
        }
        self.tokens.push(Token::Lit(num));
    }

    fn lex_string(&mut self) {
        self.advance(); // skip opening "
        let mut s = String::new();
        while self.peek() != '"' && self.peek() != '\0' {
            s.push(self.peek());
            self.advance();
        }
        self.advance(); // skip closing "
        self.tokens.push(Token::StringLit(s));
    }

    fn lex_symbol(&mut self) {
        let tok = match self.peek() {
            '(' => Token::LParen,
            ')' => Token::RParen,
            '{' => Token::LBrace,
            '}' => Token::RBrace,
            '[' => Token::LBracket,
            ']' => Token::RBracket,
            ':' => Token::Colon,
            ';' => Token::Semi,
            ',' => Token::Comma,
            '=' => Token::Eq,
            '+' => Token::Plus,
            '-' => if self.peek_next() == '>' {
                self.advance();
                Token::Arrow
            } else {
                Token::Minus
            },
            '*' => Token::Star,
            '/' => Token::Slash,
            '<' => Token::Lt,
            '>' => Token::Gt,
            '.' => Token::Dot,
            '?' => Token::Question,
            _ => Token::Eof,
        };
        self.advance();
        self.tokens.push(tok);
    }
}

#[derive(Clone, Debug, PartialEq)]
enum AstNode {
    Program(Vec<AstNode>),
    FuncDef {
        name: String,
        generics: Vec<String>,
        params: Vec<(String, String)>,
        ret: String,
        body: Vec<AstNode>,
    },
    ConceptDef {
        name: String,
        generics: Vec<String>,
        methods: Vec<AstNode>,
    },
    ImplBlock {
        concept: String,
        ty: String,
        body: Vec<AstNode>,
    },
    StructDef {
        name: String,
        fields: Vec<(String, String)>,
    },
    EnumDef {
        name: String,
        variants: Vec<(String, Vec<String>)>,
    },
    Call {
        receiver: Option<Box<AstNode>>,
        method: String,
        args: Vec<AstNode>,
        type_args: Vec<String>,
    },
    PathCall {
        path: Vec<String>,
        method: String,
        args: Vec<AstNode>,
    },
    Spawn {
        func: String,
        args: Vec<AstNode>,
    },
    Lit(i64),
    StringLit(String),
    Var(String),
    Assign(Box<AstNode>, Box<AstNode>),
    BinaryOp {
        op: String,
        left: Box<AstNode>,
        right: Box<AstNode>,
    },
    Return(Box<AstNode>),
    If {
        cond: Box<AstNode>,
        then_: Vec<AstNode>,
        else_: Vec<AstNode>,
    },
    Defer(Box<AstNode>),
    ExprStmt(Box<AstNode>),
}

struct Parser {
    tokens: Vec<Token>,
    pos: i64,
}

impl Parser {
    fn new(tokens: Vec<Token>) -> Self {
        Self { tokens, pos: 0 }
    }

    fn parse(&mut self) -> AstNode {
        let mut nodes = vec![];
        while !self.at_end() {
            nodes.push(self.parse_top_level());
        }
        AstNode::Program(nodes)
    }

    fn parse_top_level(&mut self) -> AstNode {
        match self.peek() {
            Token::KeywordFn => self.parse_func_def(),
            Token::KeywordConcept => self.parse_concept_def(),
            Token::KeywordImpl => self.parse_impl_block(),
            Token::KeywordStruct => self.parse_struct_def(),
            Token::KeywordEnum => self.parse_enum_def(),
            _ => {
                self.advance();
                AstNode::Lit(0) // skip unknown
            }
        }
    }

    fn parse_func_def(&mut self) -> AstNode {
        self.expect(Token::KeywordFn);
        let name = self.expect_ident();
        let generics = self.parse_generics();
        self.expect(Token::LParen);
        let params = self.parse_params();
        self.expect(Token::RParen);
        let ret = if self.consume(Token::Arrow) {
            self.expect_ident()
        } else {
            "i64".to_string()
        };
        let body = self.parse_block();
        AstNode::FuncDef {
            name,
            generics,
            params,
            ret,
            body,
        }
    }

    fn parse_generics(&mut self) -> Vec<String> {
        if self.consume(Token::Lt) {
            let mut gens = vec![];
            loop {
                gens.push(self.expect_ident());
                if !self.consume(Token::Comma) {
                    break;
                }
            }
            self.expect(Token::Gt);
            gens
        } else {
            vec![]
        }
    }

    fn parse_params(&mut self) -> Vec<(String, String)> {
        let mut params = vec![];
        if self.peek() != Token::RParen {
            loop {
                let name = self.expect_ident();
                self.expect(Token::Colon);
                let ty = self.expect_ident();
                params.push((name, ty));
                if !self.consume(Token::Comma) {
                    break;
                }
            }
        }
        params
    }

    fn parse_block(&mut self) -> Vec<AstNode> {
        self.expect(Token::LBrace);
        let mut stmts = vec![];
        while self.peek() != Token::RBrace && !self.at_end() {
            stmts.push(self.parse_stmt());
        }
        self.expect(Token::RBrace);
        stmts
    }

    fn parse_stmt(&mut self) -> AstNode {
        match self.peek() {
            Token::KeywordReturn => {
                self.advance();
                let expr = self.parse_expr();
                self.expect(Token::Semi);
                AstNode::Return(Box::new(expr))
            }
            Token::KeywordIf => self.parse_if(),
            Token::KeywordDefer => {
                self.advance();
                let expr = self.parse_expr();
                self.expect(Token::Semi);
                AstNode::Defer(Box::new(expr))
            }
            _ => {
                let expr = self.parse_expr();
                if self.consume(Token::Semi) {
                    AstNode::ExprStmt(Box::new(expr))
                } else {
                    expr // expression as statement
                }
            }
        }
    }

    fn parse_if(&mut self) -> AstNode {
        self.expect(Token::KeywordIf);
        let cond = Box::new(self.parse_expr());
        let then_ = self.parse_block();
        let else_ = if self.consume(Token::KeywordElse) {
            self.parse_block()
        } else {
            vec![]
        };
        AstNode::If { cond, then_, else_ }
    }

    fn parse_expr(&mut self) -> AstNode {
        self.parse_assign()
    }

    fn parse_assign(&mut self) -> AstNode {
        let left = self.parse_binary();
        if self.consume(Token::Eq) {
            let right = self.parse_expr();
            AstNode::Assign(Box::new(left), Box::new(right))
        } else {
            left
        }
    }

    fn parse_binary(&mut self) -> AstNode {
        let mut left = self.parse_primary();
        while let Some(op) = self.binary_op() {
            self.advance();
            let right = self.parse_primary();
            left = AstNode::BinaryOp {
                op,
                left: Box::new(left),
                right: Box::new(right),
            };
        }
        left
    }

    fn parse_primary(&mut self) -> AstNode {
        match self.peek() {
            Token::Lit(n) => {
                self.advance();
                AstNode::Lit(n)
            }
            Token::StringLit(s) => {
                self.advance();
                AstNode::StringLit(s)
            }
            Token::Ident(name) => {
                self.advance();
                if self.peek() == Token::LParen {
                    self.parse_call(Some(name))
                } else if self.peek() == Token::Lt {
                    // generic path call (stub)
                    self.parse_call(Some(name))
                } else {
                    AstNode::Var(name)
                }
            }
            Token::LParen => {
                self.advance();
                let expr = self.parse_expr();
                self.expect(Token::RParen);
                expr
            }
            Token::KeywordSpawn => {
                self.advance();
                let func = self.expect_ident();
                self.expect(Token::LParen);
                let args = self.parse_args();
                self.expect(Token::RParen);
                AstNode::Spawn { func, args }
            }
            _ => {
                self.advance();
                AstNode::Lit(0)
            }
        }
    }

    fn parse_call(&mut self, method: Option<String>) -> AstNode {
        let type_args = self.parse_generics();
        self.expect(Token::LParen);
        let args = self.parse_args();
        self.expect(Token::RParen);
        AstNode::Call {
            receiver: None,
            method: method.unwrap_or("".to_string()),
            args,
            type_args,
        }
    }

    fn parse_args(&mut self) -> Vec<AstNode> {
        let mut args = vec![];
        if self.peek() != Token::RParen {
            loop {
                args.push(self.parse_expr());
                if !self.consume(Token::Comma) {
                    break;
                }
            }
        }
        args
    }

    fn parse_concept_def(&mut self) -> AstNode {
        self.expect(Token::KeywordConcept);
        let name = self.expect_ident();
        let generics = self.parse_generics();
        self.expect(Token::LBrace);
        let mut methods = vec![];
        while self.peek() != Token::RBrace {
            methods.push(self.parse_func_def());
        }
        self.expect(Token::RBrace);
        AstNode::ConceptDef { name, generics, methods }
    }

    fn parse_impl_block(&mut self) -> AstNode {
        self.expect(Token::KeywordImpl);
        let concept = self.expect_ident();
        let generics = self.parse_generics(); // optional on impl
        // optional 'for'
        let _ = self.consume(Token::KeywordFor);
        let ty = self.expect_ident();
        let body = self.parse_block();
        AstNode::ImplBlock { concept, ty, body }
    }

    fn parse_struct_def(&mut self) -> AstNode {
        self.expect(Token::KeywordStruct);
        let name = self.expect_ident();
        self.expect(Token::LBrace);
        let mut fields = vec![];
        while self.peek() != Token::RBrace {
            let name = self.expect_ident();
            self.expect(Token::Colon);
            let ty = self.expect_ident();
            fields.push((name, ty));
            self.expect(Token::Semi);
        }
        self.expect(Token::RBrace);
        AstNode::StructDef { name, fields }
    }

    fn parse_enum_def(&mut self) -> AstNode {
        self.expect(Token::KeywordEnum);
        let name = self.expect_ident();
        self.expect(Token::LBrace);
        let mut variants = vec![];
        while self.peek() != Token::RBrace {
            let name = self.expect_ident();
            let params = if self.consume(Token::LParen) {
                self.parse_params()
            } else {
                vec![]
            };
            variants.push((name, params));
            if !self.consume(Token::Comma) {
                break;
            }
        }
        self.expect(Token::RBrace);
        AstNode::EnumDef { name, variants }
    }

    fn binary_op(&self) -> Option<String> {
        match self.peek() {
            Token::Plus => Some("+".to_string()),
            Token::Minus => Some("-".to_string()),
            Token::Star => Some("*".to_string()),
            Token::Slash => Some("/".to_string()),
            _ => None,
        }
    }

    fn peek(&self) -> Token {
        self.tokens.get(self.pos as usize).cloned().unwrap_or(Token::Eof)
    }

    fn advance(&mut self) {
        self.pos += 1;
    }

    fn at_end(&self) -> bool {
        self.peek() == Token::Eof
    }

    fn consume(&mut self, expected: Token) -> bool {
        if self.peek() == expected {
            self.advance();
            true
        } else {
            false
        }
    }

    fn expect(&mut self, expected: Token) {
        if self.peek() == expected {
            self.advance();
        } else {
            // recover by skipping
            self.advance();
        }
    }

    fn expect_ident(&mut self) -> String {
        if let Token::Ident(s) = self.peek() {
            self.advance();
            s
        } else {
            self.advance();
            "".to_string()
        }
    }
}
