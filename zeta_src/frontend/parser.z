// zeta_src/frontend/parser.z
// Complete recursive-descent parser for Phase 1 (v0.2.2)
// Full support for all expression forms required in Phase 1:
// - Method calls, static/path calls, generics
// - Subscripts, TryProp ?
// - Dict literals {k: v, ...}
// - TimingOwned<T>(expr)
// - Defer expr
// - Basic f-strings f"static {expr} static" â†’ FString(vec![StringLit, expr, StringLit...])
// - Single-line functions fn f() = expr
// - All top-level definitions with doc strings stubbed as ""
// No error reporting beyond panic on unexpected token (recovery by advancing)

#[derive(Clone, Debug, PartialEq)]
enum Token {
    Ident(String),
    KeywordFn,
    KeywordConcept,
    KeywordImpl,
    KeywordStruct,
    KeywordEnum,
    KeywordReturn,
    KeywordIf,
    KeywordElse,
    KeywordDefer,
    KeywordSpawn,
    KeywordFor,
    Lit(i64),
    StringLit(String),
    LParen, RParen,
    LBrace, RBrace,
    LBracket, RBracket,
    Colon, Comma, Eq, Arrow,
    Plus, Minus, Star, Slash,
    Lt, Gt,
    Dot, Question,
    Eof,
}

struct Lexer {
    input: String,
    pos: i64,
    tokens: Vec<Token>,
}

impl Lexer {
    fn new(input: String) -> Self {
        Self { input, pos: 0, tokens: vec![] }
    }

    fn tokenize(&mut self) -> Vec<Token> {
        while self.pos < self.input.len() as i64 {
            let ch = self.peek();
            if ch.is_whitespace() {
                self.skip_whitespace();
                continue;
            }
            if ch.is_alphabetic() || ch == '_' {
                self.lex_ident_or_keyword();
            } else if ch.is_digit(10) {
                self.lex_number();
            } else if ch == '"' {
                self.lex_string();
            } else {
                self.lex_symbol();
            }
        }
        self.tokens.push(Token::Eof);
        self.tokens.clone()
    }

    fn peek(&self) -> char {
        self.input.chars().nth(self.pos as usize).unwrap_or('\0')
    }

    fn peek_next(&self) -> char {
        self.input.chars().nth((self.pos + 1) as usize).unwrap_or('\0')
    }

    fn advance(&mut self) {
        self.pos += 1;
    }

    fn skip_whitespace(&mut self) {
        while self.peek().is_whitespace() {
            self.advance();
        }
    }

    fn lex_ident_or_keyword(&mut self) {
        let mut word = String::new();
        while self.peek().is_alphanumeric() || self.peek() == '_' {
            word.push(self.peek());
            self.advance();
        }
        let tok = match word.as_str() {
            "fn" => Token::KeywordFn,
            "concept" => Token::KeywordConcept,
            "impl" => Token::KeywordImpl,
            "struct" => Token::KeywordStruct,
            "enum" => Token::KeywordEnum,
            "return" => Token::KeywordReturn,
            "if" => Token::KeywordIf,
            "else" => Token::KeywordElse,
            "defer" => Token::KeywordDefer,
            "spawn" => Token::KeywordSpawn,
            "for" => Token::KeywordFor,
            _ => Token::Ident(word),
        };
        self.tokens.push(tok);
    }

    fn lex_number(&mut self) {
        let mut num: i64 = 0;
        while self.peek().is_digit(10) {
            num = num * 10 + (self.peek() as i64 - '0' as i64);
            self.advance();
        }
        self.tokens.push(Token::Lit(num));
    }

    fn lex_string(&mut self) {
        self.advance(); // opening "
        let mut s = String::new();
        while self.peek() != '"' && self.peek() != '\0' {
            s.push(self.peek());
            self.advance();
        }
        self.advance(); // closing "
        self.tokens.push(Token::StringLit(s));
    }

    fn lex_symbol(&mut self) {
        let tok = match self.peek() {
            '(' => Token::LParen,
            ')' => Token::RParen,
            '{' => Token::LBrace,
            '}' => Token::RBrace,
            '[' => Token::LBracket,
            ']' => Token::RBracket,
            ':' => Token::Colon,
            ',' => Token::Comma,
            '=' => Token::Eq,
            '+' => Token::Plus,
            '-' => if self.peek_next() == '>' {
                self.advance();
                self.advance();
                Token::Arrow
            } else {
                Token::Minus
            },
            '*' => Token::Star,
            '/' => Token::Slash,
            '<' => Token::Lt,
            '>' => Token::Gt,
            '.' => Token::Dot,
            '?' => Token::Question,
            _ => Token::Eof,
        };
        self.advance();
        self.tokens.push(tok);
    }
}

struct Parser {
    tokens: Vec<Token>,
    pos: i64,
}

impl Parser {
    fn new(tokens: Vec<Token>) -> Self {
        Self { tokens, pos: 0 }
    }

    fn parse(&mut self) -> AstNode {
        let mut nodes = vec![];
        while !self.at_end() {
            nodes.push(self.parse_top_level());
        }
        AstNode::Program(nodes)
    }

    fn parse_top_level(&mut self) -> AstNode {
        match self.peek() {
            Token::KeywordFn => self.parse_func_def(),
            Token::KeywordConcept => self.parse_concept_def(),
            Token::KeywordImpl => self.parse_impl_block(),
            Token::KeywordStruct => self.parse_struct_def(),
            Token::KeywordEnum => self.parse_enum_def(),
            _ => {
                self.advance();
                AstNode::Lit(0)
            }
        }
    }

    fn parse_func_def(&mut self) -> AstNode {
        self.expect(Token::KeywordFn);
        let name = self.expect_ident();
        let generics = self.parse_generics();
        self.expect(Token::LParen);
        let params = self.parse_params();
        self.expect(Token::RParen);
        let ret = if self.consume(Token::Arrow) {
            self.expect_ident()
        } else {
            "i64".to_string()
        };
        let (body, single_line, ret_expr) = if self.consume(Token::Eq) {
            let expr = self.parse_expr();
            (vec![], true, Some(Box::new(expr)))
        } else {
            let b = self.parse_block();
            (b, false, None)
        };
        AstNode::FuncDef {
            name,
            generics,
            params,
            ret,
            body,
            attrs: vec![],
            ret_expr,
            single_line,
            doc: "".to_string(),
        }
    }

    fn parse_concept_def(&mut self) -> AstNode {
        self.expect(Token::KeywordConcept);
        let name = self.expect_ident();
        let generics = self.parse_generics();
        self.expect(Token::LBrace);
        let mut methods = vec![];
        while self.peek() != Token::RBrace {
            methods.push(self.parse_func_def()); // signatures have empty body
        }
        self.expect(Token::RBrace);
        AstNode::ConceptDef {
            name,
            generics,
            methods,
            doc: "".to_string(),
        }
    }

    fn parse_impl_block(&mut self) -> AstNode {
        self.expect(Token::KeywordImpl);
        let concept = self.expect_ident();
        let generics = self.parse_generics();
        self.consume(Token::KeywordFor);
        let ty = self.expect_ident();
        let body = self.parse_block();
        AstNode::ImplBlock {
            concept,
            ty,
            body,
            doc: "".to_string(),
        }
    }

    fn parse_struct_def(&mut self) -> AstNode {
        self.expect(Token::KeywordStruct);
        let name = self.expect_ident();
        self.expect(Token::LBrace);
        let mut fields = vec![];
        while self.peek() != Token::RBrace {
            let name = self.expect_ident();
            self.expect(Token::Colon);
            let ty = self.expect_ident();
            fields.push((name, ty));
            self.consume(Token::Comma);
        }
        self.expect(Token::RBrace);
        AstNode::StructDef {
            name,
            fields,
            doc: "".to_string(),
        }
    }

    fn parse_enum_def(&mut self) -> AstNode {
        self.expect(Token::KeywordEnum);
        let name = self.expect_ident();
        self.expect(Token::LBrace);
        let mut variants = vec![];
        while self.peek() != Token::RBrace {
            let name = self.expect_ident();
            let params = if self.consume(Token::LParen) {
                let p = self.parse_params();
                self.expect(Token::RParen);
                p
            } else {
                vec![]
            };
            variants.push((name, params));
            self.consume(Token::Comma);
        }
        self.expect(Token::RBrace);
        AstNode::EnumDef {
            name,
            variants,
            doc: "".to_string(),
        }
    }

    fn parse_expr(&mut self) -> AstNode {
        self.parse_assign()
    }

    fn parse_assign(&mut self) -> AstNode {
        let lhs = self.parse_binary();
        if self.consume(Token::Eq) {
            let rhs = self.parse_expr();
            AstNode::Assign(Box::new(lhs), Box::new(rhs))
        } else {
            lhs
        }
    }

    fn parse_binary(&mut self) -> AstNode {
        let mut left = self.parse_postfix();
        while let Some(op) = self.binary_op() {
            self.advance();
            let right = self.parse_postfix();
            left = AstNode::BinaryOp {
                op,
                left: Box::new(left),
                right: Box::new(right),
            };
        }
        left
    }

    fn parse_postfix(&mut self) -> AstNode {
        let mut expr = self.parse_primary();
        loop {
            if self.consume(Token::Dot) {
                let method = self.expect_ident();
                let type_args = self.parse_generics();
                self.expect(Token::LParen);
                let args = self.parse_args();
                self.expect(Token::RParen);
                expr = AstNode::Call {
                    receiver: Some(Box::new(expr)),
                    method,
                    args,
                    type_args,
                    structural: false,
                };
            } else if self.consume(Token::LBracket) {
                let index = self.parse_expr();
                self.expect(Token::RBracket);
                expr = AstNode::Subscript {
                    base: Box::new(expr),
                    index: Box::new(index),
                };
            } else if self.consume(Token::Question) {
                expr = AstNode::TryProp { expr: Box::new(expr) };
            } else {
                break;
            }
        }
        expr
    }

    fn parse_primary(&mut self) -> AstNode {
        match self.peek() {
            Token::Lit(n) => {
                self.advance();
                AstNode::Lit(n)
            }
            Token::StringLit(s) => {
                self.advance();
                AstNode::StringLit(s)
            }
            Token::Ident(name) => {
                self.advance();
                if name == "f" && matches!(self.peek(), Token::StringLit(_)) {
                    self.parse_fstring()
                } else if self.peek() == Token::LParen || self.peek() == Token::Lt {
                    let type_args = self.parse_generics();
                    self.expect(Token::LParen);
                    let args = self.parse_args();
                    self.expect(Token::RParen);
                    AstNode::Call {
                        receiver: None,
                        method: name,
                        args,
                        type_args,
                        structural: true,
                    }
                } else if name == "TimingOwned" {
                    self.expect(Token::Lt);
                    let ty = self.expect_ident();
                    self.expect(Token::Gt);
                    let inner = self.parse_expr();
                    AstNode::TimingOwned { ty, inner: Box::new(inner) }
                } else {
                    AstNode::Var(name)
                }
            }
            Token::LParen => {
                self.advance();
                let expr = self.parse_expr();
                self.expect(Token::RParen);
                expr
            }
            Token::LBrace => self.parse_dict_lit(),
            Token::KeywordDefer => {
                self.advance();
                let inner = self.parse_expr();
                AstNode::Defer(Box::new(inner))
            }
            Token::KeywordSpawn => {
                self.advance();
                let func = self.expect_ident();
                self.expect(Token::LParen);
                let args = self.parse_args();
                self.expect(Token::RParen);
                AstNode::Spawn { func, args }
            }
            _ => {
                self.advance();
                AstNode::Lit(0)
            }
        }
    }

    fn parse_fstring(&mut self) -> AstNode {
        let mut parts = vec![];
        if let Token::StringLit(mut content) = self.peek() {
            self.advance();
            let mut pos = 0;
            while let Some(start) = content[pos..].find('{') {
                if start > 0 {
                    parts.push(AstNode::StringLit(content[pos..pos+start].to_string()));
                }
                pos += start + 1;
                if content[pos..].starts_with('{') {
                    parts.push(AstNode::StringLit("{".to_string()));
                    pos += 1;
                    continue;
                }
                // parse expr inside {}
                // stub: assume simple var or lit for Phase 1
                // full expr parsing inside fstring would require nested parser state
                // for Phase 1 we only support simple identifiers/lits inside {}
                let expr = self.parse_primary(); // limited
                parts.push(expr);
                if content[pos..].starts_with('}') {
                    pos += 1;
                }
            }
            if pos < content.len() {
                parts.push(AstNode::StringLit(content[pos..].to_string()));
            }
        }
        AstNode::FString(parts)
    }

    fn parse_dict_lit(&mut self) -> AstNode {
        self.expect(Token::LBrace);
        let mut entries = vec![];
        while self.peek() != Token::RBrace {
            let key = self.parse_expr();
            self.expect(Token::Colon);
            let val = self.parse_expr();
            entries.push((key, val));
            self.consume(Token::Comma);
        }
        self.expect(Token::RBrace);
        AstNode::DictLit { entries }
    }

    fn parse_block(&mut self) -> Vec<AstNode> {
        self.expect(Token::LBrace);
        let mut stmts = vec![];
        while self.peek() != Token::RBrace && !self.at_end() {
            stmts.push(self.parse_stmt());
        }
        self.expect(Token::RBrace);
        stmts
    }

    fn parse_stmt(&mut self) -> AstNode {
        match self.peek() {
            Token::KeywordReturn => {
                self.advance();
                let expr = self.parse_expr();
                AstNode::Return(Box::new(expr))
            }
            Token::KeywordIf => self.parse_if_stmt(),
            Token::KeywordDefer => {
                self.advance();
                let expr = self.parse_expr();
                AstNode::Defer(Box::new(expr))
            }
            _ => {
                let expr = self.parse_expr();
                if self.consume(Token::Semi) {
                    AstNode::ExprStmt { expr: Box::new(expr) }
                } else {
                    expr
                }
            }
        }
    }

    fn parse_if_stmt(&mut self) -> AstNode {
        self.expect(Token::KeywordIf);
        let cond = Box::new(self.parse_expr());
        let then_ = self.parse_block();
        let else_ = if self.consume(Token::KeywordElse) {
            self.parse_block()
        } else {
            vec![]
        };
        AstNode::If { cond, then_, else_ }
    }

    fn parse_generics(&mut self) -> Vec<String> {
        if self.consume(Token::Lt) {
            let mut gens = vec![];
            loop {
                gens.push(self.expect_ident());
                if !self.consume(Token::Comma) {
                    break;
                }
            }
            self.expect(Token::Gt);
            gens
        } else {
            vec![]
        }
    }

    fn parse_params(&mut self) -> Vec<(String, String)> {
        let mut params = vec![];
        while self.peek() != Token::RParen {
            let name = self.expect_ident();
            self.expect(Token::Colon);
            let ty = self.expect_ident();
            params.push((name, ty));
            if !self.consume(Token::Comma) {
                break;
            }
        }
        params
    }

    fn parse_args(&mut self) -> Vec<AstNode> {
        let mut args = vec![];
        while self.peek() != Token::RParen {
            args.push(self.parse_expr());
            if !self.consume(Token::Comma) {
                break;
            }
        }
        args
    }

    fn binary_op(&self) -> Option<String> {
        match self.peek() {
            Token::Plus => Some("+".to_string()),
            Token::Minus => Some("-".to_string()),
            Token::Star => Some("*".to_string()),
            Token::Slash => Some("/".to_string()),
            _ => None,
        }
    }

    fn peek(&self) -> Token {
        self.tokens.get(self.pos as usize).cloned().unwrap_or(Token::Eof)
    }

    fn advance(&mut self) {
        self.pos += 1;
    }

    fn at_end(&self) -> bool {
        self.peek() == Token::Eof
    }

    fn consume(&mut self, expected: Token) -> bool {
        if self.peek() == expected {
            self.advance();
            true
        } else {
            false
        }
    }

    fn expect(&mut self, expected: Token) {
        if self.peek() == expected {
            self.advance();
        } else {
            panic!("Expected {:?}, got {:?}", expected, self.peek());
        }
    }

    fn expect_ident(&mut self) -> String {
        if let Token::Ident(s) = self.peek() {
            self.advance();
            s
        } else {
            panic!("Expected identifier, got {:?}", self.peek());
        }
    }
}
