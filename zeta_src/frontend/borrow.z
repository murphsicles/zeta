// zeta_src/frontend/borrow.z
// Complete affine borrow checker for Phase 1 (v0.2.2)
// Uses linear search Vec tuples (no generic Map yet in bootstrap)
// Full implementation matching Rust version behavior
// Speculative states stubbed (always Safe)

use zorb::frontend::ast::AstNode;

#[derive(Clone, Copy, Debug, PartialEq)]
enum BorrowState {
    Owned,
    Borrowed,
    MutBorrowed,
    Consumed,
}

#[derive(Clone, Copy, Debug, PartialEq)]
enum SpeculativeState {
    Safe,
    Speculative,
    Poisoned,
}

struct BorrowChecker {
    borrows: Vec<(String, BorrowState)>,
    affine_moves: Vec<(String, bool)>,
    speculative: Vec<(String, SpeculativeState)>,
    types: Vec<(String, String)>,
}

impl BorrowChecker {
    fn new() -> Self {
        Self {
            borrows: vec![],
            affine_moves: vec![],
            speculative: vec![],
            types: vec![],
        }
    }

    fn declare(&mut self, var: String, state: BorrowState, ty: String) {
        self.borrows.push((var.clone(), state));
        self.affine_moves.push((var.clone(), false));
        self.speculative.push((var.clone(), SpeculativeState::Safe));
        self.types.push((var, ty));
    }

    fn get_borrow(&self, var: &str) -> Option<BorrowState> {
        self.borrows.iter().rev().find(|(v, _)| v == var).map(|(_, s)| *s)
    }

    fn get_borrow_mut(&mut self, var: &str) -> Option<&mut BorrowState> {
        self.borrows.iter_mut().rev().find(|(v, _)| v == var).map(|(_, s)| s)
    }

    fn get_type(&self, var: &str) -> Option<String> {
        self.types.iter().rev().find(|(v, _)| v == var).map(|(_, t)| t.clone())
    }

    fn get_moved(&self, var: &str) -> bool {
        self.affine_moves.iter().rev().find(|(v, _)| v == var).map(|(_, m)| *m).unwrap_or(false)
    }

    fn set_moved(&mut self, var: &str, moved: bool) {
        if let Some(idx) = self.affine_moves.iter().position(|(v, _)| v == var) {
            self.affine_moves[idx].1 = moved;
        } else {
            self.affine_moves.push((var.to_string(), moved));
        }
    }

    fn is_copy(&self, ty: &str) -> bool {
        matches!(ty, "i32" | "i64" | "f32" | "bool" | "str")
    }

    pub fn check(&mut self, node: &AstNode, resolver: &Resolver) -> bool {
        match node {
            AstNode::Var(v) => {
                if let Some(state) = self.get_borrow(v) {
                    state != BorrowState::Consumed
                } else {
                    false
                }
            }
            AstNode::Assign(lhs, rhs) => {
                if !self.check(rhs, resolver) {
                    return false;
                }
                match lhs.as_ref() {
                    AstNode::Var(v) => {
                        let ty = resolver.infer_type(rhs);
                        self.declare(v.clone(), BorrowState::Owned, ty);
                        true
                    }
                    AstNode::Subscript { base, .. } => {
                        if let AstNode::Var(name) = base.as_ref() {
                            if let Some(state) = self.get_borrow_mut(name) {
                                *state = BorrowState::MutBorrowed;
                            }
                        }
                        true
                    }
                    _ => false,
                }
            }
            AstNode::BinaryOp { left, right, .. } => {
                self.check(left, resolver) && self.check(right, resolver)
            }
            AstNode::FString(parts) => parts.iter().all(|p| self.check(p, resolver)),
            AstNode::TimingOwned { inner, .. } => self.check(inner, resolver),
            AstNode::Defer(inner) => self.check(inner, resolver),
            AstNode::Call { receiver, args, .. } => {
                if let Some(r) = receiver {
                    if !self.check(r, resolver) {
                        return false;
                    }
                    if let AstNode::Var(name) = r.as_ref() {
                        if let Some(state) = self.get_borrow_mut(name) {
                            *state = BorrowState::Borrowed;
                        }
                    }
                }
                for arg in args {
                    if !self.check(arg, resolver) {
                        return false;
                    }
                    if let AstNode::Var(name) = arg {
                        if let Some(ty) = self.get_type(name) {
                            if !self.is_copy(&ty) && !self.get_moved(name) {
                                self.set_moved(name, true);
                                if let Some(state) = self.get_borrow_mut(name) {
                                    *state = BorrowState::Consumed;
                                }
                            }
                        }
                    }
                }
                true
            }
            AstNode::TryProp { expr } => self.check(expr, resolver),
            AstNode::DictLit { entries } => entries.iter().all(|(k, v)| self.check(k, resolver) && self.check(v, resolver)),
            AstNode::Subscript { base, index } => self.check(base, resolver) && self.check(index, resolver),
            AstNode::Return(inner) => self.check(inner, resolver),
            AstNode::ExprStmt { expr } => self.check(expr, resolver),
            AstNode::If { cond, then_, else_ } => {
                self.check(cond, resolver) &&
                then_.iter().all(|s| self.check(s, resolver)) &&
                else_.iter().all(|s| self.check(s, resolver))
            }
            AstNode::FuncDef { params, body, .. } => {
                for (name, ty) in params {
                    self.declare(name.clone(), BorrowState::Owned, ty.clone());
                }
                body.iter().all(|s| self.check(s, resolver))
            }
            _ => true,
        }
    }
}

struct Resolver {
    // minimal for borrow checker
}

impl Resolver {
    fn infer_type(&self, _node: &AstNode) -> String {
        "i64".to_string()
    }
}
