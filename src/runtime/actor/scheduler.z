// zeta_src/runtime/actor/scheduler.z
// Actor scheduler runtime for Zeta (self-hosted interface)
// Initializes runtime and provides spawn
// Ported from src/runtime/actor/scheduler.rs, implementations now in Zeta.

use super::channel::Channel;
use num_cpus;
use std::collections::{HashMap, VecDeque};
use std::sync::atomic::Ordering;
use std::sync::{Arc, OnceLock};
use tokio::sync::Mutex as TokioMutex;
use tokio::task;

/// Type alias for actor entry functions.
type ActorEntry = Box<dyn FnOnce(Channel) + Send + 'static>;

/// Global map of function IDs to actor entry functions.
static FUNC_MAP: OnceLock<Arc<TokioMutex<HashMap<i64, ActorEntry>>>> = OnceLock::new();

/// Registers an actor entry function and returns its ID.
pub fn register_func(f: impl FnOnce(Channel) + Send + 'static) -> i64 {
    let map = FUNC_MAP.get_or_init(|| Arc::new(TokioMutex::new(HashMap::new())));
    let id = super::channel::CHANNEL_ID_COUNTER.fetch_add(1, Ordering::SeqCst);
    let mut guard = map.blocking_lock();
    guard.insert(id, Box::new(f));
    id
}

/// Host function to spawn an actor.
pub fn host_spawn(func_id: i64) -> i64 {
    let map: Arc<TokioMutex<HashMap<i64, ActorEntry>>> = match FUNC_MAP.get() {
        Some(m) => Arc::clone(m),
        None => return -1,
    };
    let mut guard = map.blocking_lock();
    if let Some(func) = guard.remove(&func_id) {
        std::thread::spawn(move || {
            let chan = Channel::new();
            func(chan);
        });
        0
    } else {
        -1
    }
}

/// Represents an actor with its channel and entry function.
struct Actor {
    chan: Channel,
    func: Box<dyn FnOnce(Channel) + Send + 'static>,
}

/// Global singleton for the scheduler.
static SCHEDULER: OnceLock<Arc<Scheduler>> = OnceLock::new();

/// Manages scheduling of actors across threads with work-stealing.
struct Scheduler {
    actors: TokioMutex<VecDeque<Actor>>,
    _tasks: TokioMutex<Vec<task::JoinHandle<()>>>,
}

impl Scheduler {
    /// Creates a new scheduler with worker threads.
    pub async fn new(thread_count: usize) -> Arc<Self> {
        let sched = Arc::new(Self {
            actors: TokioMutex::new(VecDeque::new()),
            _tasks: TokioMutex::new(vec![]),
        });
        for _ in 0..thread_count {
            let sched_clone = Arc::clone(&sched);
            let handle = task::spawn(async move { sched_clone.worker_loop().await });
            let mut tasks = sched._tasks.lock().await;
            tasks.push(handle);
        }
        sched
    }

    /// Worker loop that processes actors or yields when idle.
    async fn worker_loop(self: Arc<Self>) {
        loop {
            let actor_opt = {
                let mut actors = self.actors.lock().await;
                actors.pop_front()
            };
            if let Some(actor) = actor_opt {
                task::spawn(async move {
                    (actor.func)(actor.chan);
                })
                .await
                .ok();
            } else {
                task::yield_now().await;
            }
        }
    }

    /// Enqueues a new actor for scheduling.
    pub async fn spawn<F>(func: F)
    where
        F: FnOnce(Channel) + Send + 'static,
    {
        let chan = Channel::new();
        let actor = Actor {
            chan: chan.clone(),
            func: Box::new(func),
        };
        let sched = SCHEDULER.get().expect("Scheduler not initialized");
        let mut actors = sched.actors.lock().await;
        actors.push_back(actor);
    }

    /// Initializes the global scheduler instance.
    pub fn init() -> Result<(), Box<dyn std::error::Error>> {
        static SINGLETON_RT: OnceLock<tokio::runtime::Runtime> = OnceLock::new();
        let rt = SINGLETON_RT.get_or_init(|| {
            tokio::runtime::Builder::new_multi_thread()
                .worker_threads(num_cpus::get().max(1))
                .enable_all()
                .build()
                .expect("Failed to create Tokio runtime")
        });
        let sched = rt.block_on(async { Self::new(num_cpus::get().max(1)).await });
        let _ = SCHEDULER.set(sched);
        Ok(())
    }
}

/// Initializes the actor runtime.
pub fn init_runtime() {
    Scheduler::init().expect("Failed to initialize scheduler");
}

/// Spawns an actor asynchronously.
pub async fn spawn<F>(f: F)
where
    F: FnOnce(Channel) + Send + 'static,
{
    Scheduler::spawn(f).await;
}

// Temporary test
fn main() -> i64 {
    println!("Actor scheduler interface ready");
    0
}
